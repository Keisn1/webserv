:PROPERTIES:
:GPTEL_MODEL: claude-3-7-sonnet-20250219
:GPTEL_BACKEND: Claude
:GPTEL_SYSTEM: You are a large language model living in Emacs and a helpful assistant. Avoid long answers.
:GPTEL_BOUNDS: ((response (369 929) (984 1681) (1783 2542) (2581 3386) (3425 4274) (4351 5526) (5641 6554)))
:END:

*** which module in python should i use for building a cgi script?

For building a CGI script in Python, use the =cgi= module from the standard library. It provides functions for parsing form data and handling CGI requests.

Basic usage example:

#+begin_src python
#!/usr/bin/env python
import cgi

print("Content-Type: text/html\n\n")  # HTTP header required for CGI
form = cgi.FieldStorage()  # Parse form data

# Access form fields
name = form.getvalue('name', 'unknown')
print(f"<html><body>Hello, {name}!</body></html>")
#+end_src

For more modern web development, consider frameworks like Flask or FastCGI instead of CGI.

*** in 3.12 it is no longer in the standard library

You're right, the =cgi= module was deprecated in Python 3.8 and removed in Python 3.12. For modern CGI scripting in Python 3.12, you have these alternatives:

1. Use the =http.server= module with CGIHTTPRequestHandler:
   #+begin_src python
   from http.server import CGIHTTPRequestHandler, HTTPServer
   #+end_src

2. Better approach: Use WSGI frameworks like:
   - Flask (lightweight): =pip install flask=
   - FastCGI via flup: =pip install flup=
   - Django (full-featured): =pip install django=

3. For simple form parsing, use =urllib.parse=:
   #+begin_src python
   import urllib.parse
   #+end_src

Most modern environments prefer WSGI or ASGI over traditional CGI for better performance.

*** give me the most simple script, which takes in a query parameter and prints it out as a string

Here's a simple CGI script for Python 3.12 that takes a query parameter and prints it out:

#+begin_src python
#!/usr/bin/env python3

import os
import urllib.parse

# HTTP header required for CGI
print("Content-Type: text/html\n")

# Get and parse query string
query_string = os.environ.get("QUERY_STRING", "")
params = urllib.parse.parse_qs(query_string)

# Get parameter 'q' (or empty string if not provided)
query = params.get('q', [''])[0]

# Output HTML
print(f"""
<html>
<body>
    <h1>Query Parameter</h1>
    <p>You entered: {query}</p>
</body>
</html>
""")
#+end_src

Save this as a =.py= file, make it executable (=chmod +x script.py=), and place it in your web server's CGI directory. Access it with: =http://yourserver/cgi-bin/script.py?q=hello=.

*** i'm missing the carriage return

You're right - CGI requires the HTTP header to be separated from the body by a blank line, which means both a carriage return and line feed. Here's the corrected script:

#+begin_src python
#!/usr/bin/env python3

import os
import urllib.parse

# HTTP header with proper CRLF
print("Content-Type: text/html")
print()  # This prints a blank line with both CR and LF

# Get and parse query string
query_string = os.environ.get("QUERY_STRING", "")
params = urllib.parse.parse_qs(query_string)

# Get parameter 'q' (or empty string if not provided)
query = params.get('q', [''])[0]

# Output HTML
print(f"""
<html>
<body>
    <h1>Query Parameter</h1>
    <p>You entered: {query}</p>
</body>
</html>
""")
#+end_src

The =print()= with empty parentheses ensures the proper header separation with both CR and LF.

*** how do i print without newline?

To print without a newline in Python, you can use the =end= parameter of the =print()= function. Here's how to modify your CGI script:

#+begin_src python
#!/usr/bin/env python3

import os
import urllib.parse

# HTTP header with proper CRLF
print("Content-Type: text/html", end="\r\n")
print(end="\r\n")  # Blank line with CRLF only

# Get and parse query string
query_string = os.environ.get("QUERY_STRING", "")
params = urllib.parse.parse_qs(query_string)

# Get parameter 'q' (or empty string if not provided)
query = params.get('q', [''])[0]

# Output HTML
print("<html>")
print("<body>")
print("    <h1>Query Parameter</h1>")
print(f"    <p>You entered: {query}</p>")
print("</body>")
print("</html>")
#+end_src

The =end="\r\n"= parameter replaces the default newline with a carriage return + line feed combination, which is the HTTP standard.

*** now i want a python script which prints out multiple query parameters

Here's a Python CGI script that prints out multiple query parameters:

#+begin_src python
#!/usr/bin/env python3

import os
import urllib.parse

# HTTP header with proper CRLF
print("Content-Type: text/html", end="\r\n")
print(end="\r\n")  # Blank line with CRLF

# Get and parse query string
query_string = os.environ.get("QUERY_STRING", "")
params = urllib.parse.parse_qs(query_string)

print("<html>")
print("<body>")
print("    <h1>Query Parameters</h1>")
print("    <table border='1'>")
print("        <tr><th>Parameter</th><th>Value(s)</th></tr>")

# Display all parameters
if params:
    for param_name, param_values in params.items():
        values_str = ", ".join(param_values)
        print(f"        <tr><td>{param_name}</td><td>{values_str}</td></tr>")
else:
    print("        <tr><td colspan='2'>No parameters found</td></tr>")

print("    </table>")
print("</body>")
print("</html>")
#+end_src

Access with multiple parameters like:
#+begin_src
http://yourserver/cgi-bin/script.py?name=John&age=30&hobby=coding&hobby=reading
#+end_src

This will display all parameters and their values in a table format, handling cases where a parameter has multiple values.

*** should a cgi always send the output of the script immediately to the client or only after end of execution?

CGI scripts send output immediately to the client as it's being generated. This is called "streaming" behavior and happens because:

1. The standard output (stdout) of the CGI script is directly connected to the client connection
2. Each =print()= statement flushes output to the client as soon as it's executed

This immediate output can be useful for:
- Long-running scripts to show progress
- Server-sent events
- Large responses where you want the client to start rendering immediately

However, this can cause issues if errors occur mid-script after headers are sent. For more control, you can:

1. Buffer output manually by storing content in a variable and printing at the end
2. Use a framework like WSGI which buffers by default
3. Use =sys.stdout = io.StringIO()= for full buffering

Most production environments today use WSGI/ASGI rather than CGI specifically because they offer better output control.

***
