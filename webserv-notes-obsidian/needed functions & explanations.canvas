{
	"nodes":[
		{"id":"f70cf1e58c00ce99","type":"text","text":"send()","x":108,"y":440,"width":250,"height":60},
		{"id":"eec0b273da66a095","type":"text","text":"socket()","x":108,"y":-600,"width":250,"height":60},
		{"id":"87a040f70a71ac0d","type":"text","text":"hton()","x":108,"y":-452,"width":250,"height":60},
		{"id":"82167987beaa431c","type":"text","text":"bind()","x":108,"y":-259,"width":250,"height":60},
		{"id":"5ac3bb28fbed77c9","type":"text","text":"listen()","x":108,"y":-100,"width":250,"height":60},
		{"id":"d49e32d1a4038717","type":"text","text":"accept()(client_socket)","x":108,"y":60,"width":250,"height":60},
		{"id":"761738b6a1649d49","type":"text","text":"recv()(client_socket)","x":108,"y":240,"width":250,"height":60},
		{"id":"23d53bc9a609131f","type":"text","text":"close()(client_socket)","x":108,"y":680,"width":250,"height":60},
		{"id":"fef13f0eaed26c91","type":"text","text":"struct sockaddr_in {\n    short sin_family;      // Address family (IPv4)\n    unsigned short sin_port;  // Port number\n    struct in_addr sin_addr;  // IP address\n    char sin_zero[8];        // Padding to make the structure 16 bytes\n};","x":1040,"y":-1560,"width":888,"height":271},
		{"id":"446749e43ba9f1a7","type":"text","text":"The `htons()` function stands for **Host To Network Short**. It converts the **port number** (`8080` in this case) from **host byte order** (the format used by your machine) to **network byte order** (which is a standardized format for sending data over the network, typically big-endian).\n\n- **Why `htons()` is needed**: Different computer architectures (x86, ARM, etc.) may store multi-byte data like port numbers in different ways. **Network byte order** ensures that all machines interpret the data correctly, no matter their architecture. So, you use `htons()` to ensure that the port number is properly formatted for network transmission.","x":1040,"y":-1175,"width":888,"height":252},
		{"id":"32ce9568dedc15cc","type":"text","text":"server:receive message and return message","x":-320,"y":-745,"width":250,"height":60},
		{"id":"291a919028895b3c","type":"text","text":"functions I see so far","x":-320,"y":-600,"width":250,"height":60},
		{"id":"9fd3c8c4547c2b2b","type":"text","text":"### **What is `listen()`?**\n\nThe `listen()` function is used to **mark a socket as a server** that is **ready to accept incoming connections**. It’s typically called after the socket has been bound to a specific address and port with `bind()`.\n\n### **Definition of `listen()`**\n\nHere’s the function prototype for `listen()`:\n\ncpp\n\n复制编辑\n\n`int listen(int sockfd, int backlog);`\n\n### **Parameters of `listen()`**\n\n1. **`sockfd`**:\n    \n    - This is the **socket descriptor** returned by the `socket()` function. It represents the socket that will be listening for incoming connections.\n        \n2. **`backlog`**:\n    \n    - This defines the **maximum length** of the queue of pending connections that are waiting to be accepted by the server.\n        \n    - When a client tries to connect to the server, the connection request is put into this queue before the server accepts it. If the queue is full, new incoming connection requests may be rejected.\n        \n    - The backlog value is an integer that typically ranges from `5` to `128`, but the actual limit depends on the system configuration.\n        \n\n### **Return Value of `listen()`**\n\n- **On success**: It returns **0**.\n    \n- **On failure**: It returns **-1**, and the `errno` will be set to indicate the error.\n    \n\n### **Why Use `listen()`?**\n\nWhen a server socket is created and bound to an address and port, it is still not actively listening for incoming connections. The `listen()` function tells the system that:\n\n- The server is **ready to accept incoming connections**.\n    \n- The socket should now be placed in a **listening state** where it will wait for client requests.\n    \n\nWithout calling `listen()`, the server won’t be able to process any incoming client connections, even if they are sent to the correct IP address and port. It's like opening the door of a shop — before customers can enter (connections can be accepted), you need to unlock the door (listen).\n\n---\n\n### **How to Use `listen()`**\n\nHere’s how you would use `listen()` after binding the socket to an address:\n\n1. **Create the socket** using `socket()`.\n    \n2. **Prepare the server address** using `sockaddr_in`.\n    \n3. **Bind** the socket to the address using `bind()`.\n    \n4. **Call `listen()`** to start accepting connections.\n\n### **Why Do We Need `listen()`?**\n\nWhen you run a server, you want to receive client requests. However, before the server can **accept** those requests, it needs to be placed in a **listening state**. The `listen()` function prepares the server socket to wait for incoming connections.\n\nThink of it like a **telephone**:\n\n- **`socket()`** creates the phone.\n    \n- **`bind()`** assigns a phone number to the phone (like assigning an address and port).\n    \n- **`listen()`** makes the phone ring, indicating that the server is ready to pick up the call (accept the connection).\n    \n\nWithout `listen()`, the server would not be able to **accept incoming connections**, and clients trying to connect would receive an error.","x":1040,"y":-436,"width":888,"height":300},
		{"id":"66ec83b728937025","type":"text","text":"### **What is `accept()`?**\n\nThe `accept()` function is used to **accept** an incoming connection request from a client. When the server has called `listen()` to begin listening for incoming connections, it can then call `accept()` to actually establish a communication channel with a client.\n\nOnce a connection is accepted, the server can start **sending and receiving data** to and from the client. The `accept()` function returns a **new socket** that is specifically connected to that client.\n\n### **Definition of `accept()`**\n\nHere’s the function prototype for `accept()`:\n\ncpp\n`int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`\n\n### **Parameters of `accept()`**\n\n1. **`sockfd`**:\n    \n    - This is the **listening socket descriptor**, the one created by `socket()` and bound with `bind()`. It has been set into the listening state by calling `listen()`.\n        \n2. **`addr`**:\n    \n    - This is a pointer to a `sockaddr` structure, which will be filled with the client's **address information** (IP and port). This allows you to know which client has connected.\n        \n3. **`addrlen`**:\n    \n    - This is a pointer to a `socklen_t` variable that holds the size of the `addr` structure. It will be updated to reflect the actual size of the client’s address once the function returns.\n        \n\n### **Return Value of `accept()`**\n\n- **On success**: It returns a **new socket descriptor** that is specifically dedicated to the connection with the client. This new socket can be used to **communicate** with the client (send and receive data).\n    \n- **On failure**: It returns **-1**, and the `errno` will be set to indicate the error (e.g., if the socket is not in the listening state or there are network issues).\n    \n\n### **Why Use `accept()`?**\n\nWhen a client attempts to connect to a server, the connection request is placed into the **queue** of pending connections. The `accept()` function is the way the server actually retrieves a **client connection** from this queue and establishes a **communication channel**.\n\nOnce a connection is accepted:\n\n- The server can start sending data to the client (e.g., HTTP responses).\n    \n- The server can receive data from the client (e.g., HTTP requests).\n    \n\nWithout `accept()`, the server cannot communicate with clients.\n\n---\n\n### **How to Use `accept()`**\n\nHere’s how `accept()` fits into the server process:\n\n1. **Create a socket** using `socket()`.\n    \n2. **Prepare the server address** using `sockaddr_in`.\n    \n3. **Bind** the socket to the address using `bind()`.\n    \n4. **Call `listen()`** to start listening for incoming connections.\n    \n5. **Accept** incoming connections using `accept()`.\n\n### **Why Do We Need `accept()`?**\n\nThe `accept()` function is necessary because it allows the server to establish a **communication channel** with an individual client. While `listen()` simply prepares the server to accept connections, `accept()` is the function that actually hands the server a new socket through which it can start **exchanging data** with the client.\n\nTo visualize it, here’s a rough breakdown:\n\n- **`listen()`**: The server \"opens its door\" to incoming connections and starts \"hearing\" clients knocking.\n    \n- **`accept()`**: The server \"opens the door\" to a client and lets them inside, creating a dedicated channel for communication.\n    \n\nWithout `accept()`, the server would never interact with the client, even though the connection request is being received.","x":1040,"y":-37,"width":888,"height":280},
		{"id":"5d4c8f4711e9129c","type":"text","text":"### **What is `bind()`?**\n\nThe `bind()` function is used to **associate** a socket (created with `socket()`) with a specific **IP address** and **port number**. Without binding the socket, the server won't know where to listen for incoming connections.\n\n### **Definition of `bind()`**\n\nHere’s the function signature:\n\ncpp\n`int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`\n\n### **Parameters of `bind()`**\n\n1. **`sockfd`**:\n    \n    - This is the socket descriptor returned by the `socket()` function. It represents the socket that will be bound to a specific address.\n        \n2. **`addr`**:\n    \n    - This is a pointer to a **`sockaddr`** structure (specifically, **`sockaddr_in`** for IPv4 addresses) that contains the **address and port** to bind the socket to.\n        \n    - For IPv4, this is usually a `sockaddr_in` structure, which contains:\n        \n        - The address family (`sin_family`).\n            \n        - The port number (`sin_port`).\n            \n        - The IP address (`sin_addr`).\n            \n3. **`addrlen`**:\n    \n    - This specifies the size of the `addr` structure. It is usually the size of the `sockaddr_in` structure, which is typically 16 bytes for IPv4.\n        \n\n### **Return Value of `bind()`**\n\n- **On success**: It returns **0**.\n    \n- **On failure**: It returns **-1**, and the **errno** is set to indicate the error (e.g., if the port is already in use, or if you don't have permission to bind to that port).\n    \n\n### **Why Use `bind()`?**\n\nWhen a server is set up to listen for incoming requests, the **socket** must be associated with a **specific address (IP)** and **port**. Binding the socket allows the server to know:\n\n- **Where** (which IP address) it will accept connections.\n    \n- **On which port** it will accept connections.\n    \n\n### **Why do you need it?**\n\nWithout binding the socket to an IP address and port, the system wouldn’t know where the server should listen for incoming network connections. It would essentially be \"listening in the void\" with no idea where to accept requests.\n\n---\n\n### **How to Use `bind()`**\n\nHere’s how you would use `bind()` in the context of a simple server:\n\n1. **Create a socket** with `socket()`.\n    \n2. **Prepare the address** using a `sockaddr_in` structure.\n    \n3. **Call `bind()`** to bind the socket to the address and port.\n    \n4. **Listen** for incoming connections.\n\n### **Why Do We Need `bind()`?**\n\nWithout binding the socket to a specific address and port, the server would be unable to communicate over the network. **`bind()`** is like telling the server, \"I will be listening for incoming connections on this specific port.\" It's a way of **\"assigning\"** a known address and port for the server to be reachable.","x":1040,"y":-800,"width":888,"height":263},
		{"id":"8cc23aafd157dcb5","type":"text","text":"### **What is `send()`?**\n\nThe `send()` function is used to send data through a socket. Once the server has processed the request or message from the client (using `recv()`), it uses `send()` to send a response back to the client.\n\n### **Definition of `send()`**\n\nHere’s the function prototype for `send()`:\n\ncpp\n\n复制编辑\n\n`ssize_t send(int sockfd, const void *buf, size_t len, int flags);`\n\n### **Parameters of `send()`**\n\n1. **`sockfd`**:\n    \n    - This is the **socket descriptor** (usually returned by `accept()`). It represents the communication channel with the client. You send the data to this socket.\n        \n2. **`buf`**:\n    \n    - This is a pointer to the **buffer** containing the data that you want to send. The data could be a string, an array, or any other type of memory block that holds the message.\n        \n3. **`len`**:\n    \n    - This is the **length** of the data to be sent, typically the number of bytes in the `buf` that you wish to send.\n        \n4. **`flags`**:\n    \n    - These are options that modify the behavior of `send()`. Common flags include:\n        \n        - `0`: Default behavior (send the data).\n            \n        - `MSG_CONFIRM`: Used to confirm that the data has been sent successfully.\n            \n        - `MSG_DONTWAIT`: Makes the function non-blocking (returns immediately if no data can be sent).\n            \n        - `MSG_NOSIGNAL`: Suppresses `SIGPIPE` signals when sending data to a closed socket.\n            \n\n### **Return Value of `send()`**\n\n- **On success**: The function returns the number of bytes sent, which should be equal to `len` if the whole buffer was sent. However, this may be less than the requested amount if there’s a buffer limit or network congestion.\n    \n- **On failure**: It returns **-1**, and `errno` will be set to indicate the error (e.g., socket closed, no space in buffer).\n    \n\n### **Why Use `send()`?**\n\nOnce the server has processed the client's request (or has something to send), it needs to send a **response** back to the client. This could be:\n\n- A response to an HTTP request (e.g., sending an HTML page).\n    \n- A simple acknowledgment message.\n    \n- Any other type of data that needs to be sent over the socket.\n    \n\nWithout `send()`, the server wouldn’t be able to communicate the result of its processing or provide any meaningful output to the client.\n\n---\n\n### **How to Use `send()`**\n\nOnce the connection is established and you’ve received data (using `recv()`), you can use `send()` to send the data back to the client.\n\n### **Why Do We Need `send()`?**\n\nThe `send()` function is crucial because it allows the server to **send a response** back to the client. Without `send()`, the server would not be able to send any data or communicate the result of its operations (such as responding to an HTTP request).\n\nIn simple terms, after receiving data from the client with `recv()`, `send()` is the way for the server to **send information back**, whether it's a simple acknowledgment, an error message, or more complex data.","x":1040,"y":763,"width":888,"height":250},
		{"id":"1855ddcb33a37a60","type":"text","text":"### **What is `close()`?**\n\nThe `close()` function is used to **close a file descriptor**, which in the case of socket programming, includes the **socket descriptor** that was used to communicate with the client.\n\nWhen you create a socket using `socket()`, the operating system gives you a file descriptor (an integer) that represents that socket. After you've finished using the socket (whether you've sent or received data), you should call `close()` to **close** the socket and **release system resources** that were allocated for it.\n\n### **Definition of `close()`**\n\nHere’s the function prototype for `close()`:\n\ncpp\n\n复制编辑\n\n`int close(int fd);`\n\n### **Parameters of `close()`**\n\n- **`fd`**: This is the **file descriptor** that you want to close. In the case of socket programming, this will typically be a socket descriptor returned by `socket()` (for the server) or `accept()` (for the client connection).\n    \n\n### **Return Value of `close()`**\n\n- **On success**: The function returns `0`.\n    \n- **On failure**: It returns `-1` and sets `errno` to indicate the error.\n    \n\n### **Why Use `close()`?**\n\nOnce the server (or client) has finished its communication, it is important to **close the socket**. Here’s why:\n\n1. **Release System Resources**:\n    \n    - Each open socket consumes system resources (e.g., memory, file descriptors). If you don't close the socket, it might lead to resource exhaustion. A system has a limited number of file descriptors that can be open at any given time. Not closing sockets properly can lead to **file descriptor leakage**, where the server runs out of available file descriptors, which can lead to failure when trying to open new sockets.\n        \n2. **Graceful Shutdown of Communication**:\n    \n    - By calling `close()`, you **inform the operating system** that you're done using the socket. This allows the OS to clean up any associated buffers or internal data structures.\n        \n3. **Avoiding Unwanted Side Effects**:\n    \n    - If you don’t close the socket, the server might leave it open. This could unintentionally keep connections hanging around or cause other errors in later executions of the program.\n        \n4. **Error Handling**:\n    \n    - Closing the socket ensures you’ve finished handling communication with the client or server and have properly terminated the connection.\n\n### **Why Is It Important to Call `close()`?**\n\n- **Releasing Resources**: Each open socket consumes system resources (e.g., file descriptors, memory). If you don’t call `close()`, the resources will not be released and could lead to resource exhaustion (if too many sockets are open and not closed).\n    \n- **Avoiding Resource Leaks**: Failing to close sockets after communication can lead to **file descriptor leaks**. Every open socket uses one file descriptor, and most operating systems limit the number of file descriptors a process can have. If your server runs out of file descriptors, it won’t be able to open new sockets.\n    \n- **Graceful Shutdown**: Calling `close()` signals the operating system that you're finished with the socket and the communication is complete. This allows the OS to clean up any resources or buffers related to the socket.","x":1040,"y":1193,"width":888,"height":220},
		{"id":"87d145e78e795476","type":"text","text":"NON-BLOCKING keyword appear here","x":2040,"y":463,"width":250,"height":60},
		{"id":"a546675539180963","type":"text","text":"SIGPIPE and ERRNO keyword appear here","x":2040,"y":858,"width":250,"height":60},
		{"id":"67f1de69009f54c0","type":"text","text":"### What is `socket()`?\n\nThe `socket()` function is used to **create a socket**, which is essentially an endpoint for communication. In network programming, a socket allows programs (or processes) to send and receive data over a network. Think of it as a \"door\" through which data enters and exits your application.\n\n### **Definition of `socket()`**\n\nIn C++, the `socket()` function is defined in the **sys/socket.h** header file (on Unix-like systems like Linux and macOS). Here’s the function prototype:\n\ncpp\n\n复制编辑\n\n`int socket(int domain, int type, int protocol);`\n\n### **Parameters of `socket()`**\n\n1. **domain** (address family): This specifies the **protocol family** used for communication. Common values are:\n    \n    - `AF_INET`: IPv4 Internet Protocol (used for most internet communications).\n        \n    - `AF_INET6`: IPv6 Internet Protocol.\n        \n    - `AF_UNIX`: Used for inter-process communication on the same machine (local sockets).\n        \n2. **type** (socket type): This specifies the type of socket, which determines how data will be transmitted.\n    \n    - `SOCK_STREAM`: **TCP** (reliable, connection-oriented). This is used for **stream-based** communication.\n        \n    - `SOCK_DGRAM`: **UDP** (unreliable, connectionless). This is used for **datagram-based** communication, where each message is independent.\n        \n3. **protocol** (protocol): This defines the specific **protocol** used for the communication. Typically, you can set this to `0` (or let the system choose), which automatically selects the appropriate protocol for the specified socket type.\n    \n    - For `SOCK_STREAM`, the protocol is usually `IPPROTO_TCP` (TCP).\n        \n    - For `SOCK_DGRAM`, the protocol is usually `IPPROTO_UDP` (UDP).\n        \n    \n    Most of the time, you don't need to specify this because it's implied by the `type` of socket.\n    \n\n### **Return Value of `socket()`**\n\n- **On success**: It returns a **non-negative integer**, which represents the socket descriptor (a reference to the open socket).\n    \n- **On failure**: It returns **-1**, and you can check the **errno** to see the reason for the failure.\n    \n\n### **Purpose of Using `socket()`**\n\nWhen you create a socket using `socket()`, you're setting up an endpoint to communicate over the network. The socket allows your server to:\n\n- **Send** data to another machine.\n    \n- **Receive** data from another machine.\n    \n\nThe socket itself is not yet connected to anything; it's simply a communication endpoint.","x":1040,"y":-1920,"width":888,"height":199},
		{"id":"9d072e3edacceb00","type":"text","text":"### Summary\n\n- `socket()` creates a **communication endpoint** for the server or client.\n    \n- It allows programs to **send and receive data** over the network.\n    \n- The function takes three parameters: domain, type, and protocol to define how data should be handled.\n    \n- The function returns a **socket descriptor**, which is then used to bind, listen, accept, or connect to other machines.","x":2520,"y":-1920,"width":560,"height":199},
		{"id":"049932207a8d8a29","type":"text","text":"### **1. `server_addr.sin_family = AF_INET;`**\n\n- **Purpose**: The `sin_family` field indicates which **address family** this socket will use. It tells the system that the socket will be using **IPv4** addressing.\n    \n- **Why you need it**: This is required because different address families exist (e.g., `AF_INET` for IPv4, `AF_INET6` for IPv6, `AF_UNIX` for local sockets). You’re specifying that the socket will communicate using **IPv4** addresses.\n    \n\n---\n\n### **2. `server_addr.sin_addr.s_addr = INADDR_ANY;`**\n\n- **Purpose**: The `sin_addr.s_addr` field represents the **IP address** that the socket should bind to.\n    \n- **`INADDR_ANY`**: This special constant means that the server will accept connections on **any of the available network interfaces** (i.e., any IP address assigned to the machine). Essentially, it allows your server to listen on **all network interfaces** (local IPs, public IP, etc.) without specifying a particular one.\n    \n- **Why you need it**: This is useful when you want your server to be accessible from **any network interface** on the machine. If you specified a specific IP address (e.g., `127.0.0.1` for local communication), the server would only accept connections from that specific IP, limiting access to only that network interface.\n    \n\n---\n\n### **3. `server_addr.sin_port = htons(8080);`**\n\n- **Purpose**: The `sin_port` field represents the **port number** that the server will listen on.\n    \n- **Why you need it**: By binding to a port, the server is saying, \"I am listening for incoming connections on port 8080.\" This is the port the clients will use to connect to the server. Common ports are `80` for HTTP and `443` for HTTPS, but in your example, it's using `8080`.","x":2520,"y":-1524,"width":560,"height":199},
		{"id":"606314345d2960df","type":"text","text":"### **What is `recv()`?**\n\nThe `recv()` function is used to receive data from a socket. It is a **blocking function**, which means it will wait until data is available to be read or the connection is closed before returning control to the program.\n\n### **Definition of `recv()`**\n\nHere’s the function prototype for `recv()`:\n\ncpp\n\n复制编辑\n\n`ssize_t recv(int sockfd, void *buf, size_t len, int flags);`\n\n### **Parameters of `recv()`**\n\n1. **`sockfd`**:\n    \n    - This is the **socket descriptor** from which data will be read. It’s typically the **new socket** returned by the `accept()` function, which represents the communication channel with the client.\n        \n2. **`buf`**:\n    \n    - This is a pointer to a **buffer** where the received data will be stored. The buffer is usually a character array or a pointer to a block of memory large enough to hold the incoming data.\n        \n3. **`len`**:\n    \n    - This is the size of the **buffer** (i.e., the maximum number of bytes to read). You must ensure that this size is large enough to hold the expected incoming data.\n        \n4. **`flags`**:\n    \n    - These are options that modify the behavior of `recv()`. Typically, `0` is used for default behavior. Some possible flags include:\n        \n        - `MSG_WAITALL`: Tells the system to wait for the full amount of data specified by `len` to be received.\n            \n        - `MSG_PEEK`: Allows the program to look at the data without removing it from the queue.\n            \n        - `MSG_DONTWAIT`: Makes the function non-blocking. If no data is available, it returns immediately with an error.\n            \n\n### **Return Value of `recv()`**\n\n- **On success**: The function returns the number of bytes received, which could be **less than the number requested** if the data was fragmented. A return value of **0** means the client has closed the connection.\n    \n- **On failure**: It returns **-1**, and `errno` will be set to indicate the error.\n    \n\n### **Why Use `recv()`?**\n\nOnce the server has accepted a connection, it needs a way to read the data sent by the client. This is where `recv()` comes in. It allows the server to:\n\n- Receive **incoming messages** from the client.\n    \n- Read **requests** (for example, an HTTP request).\n    \n- Receive **data in chunks**, as TCP/IP is a **streaming protocol** (data may arrive in pieces).\n    \n\nWithout `recv()`, the server would have no way to read or process any data sent by the client.\n\n---\n\n### **How to Use `recv()`**\n\nHere's a typical use case of `recv()` in a server that communicates with a client. The server waits for incoming data from the client (after calling `accept()`), reads it using `recv()`, and then processes it.\n\n### **Why Do We Need `recv()`?**\n\nThe `recv()` function is crucial because it allows the server to **read incoming data** from the client over the established connection. Without `recv()`, the server wouldn't be able to process any data that the client sends. This is especially important in protocols like **HTTP**, where the server needs to read client requests (e.g., HTTP GET requests) in order to respond.\n\nThink of `recv()` like the server **listening** to what the client says. After the server has accepted the connection, `recv()` is the function that reads the actual message (such as an HTTP request or other data).","x":1040,"y":363,"width":888,"height":260}
	],
	"edges":[
		{"id":"c95859ec2e927fdf","fromNode":"eec0b273da66a095","fromSide":"right","toNode":"67f1de69009f54c0","toSide":"left"},
		{"id":"707c1a6099e2129e","fromNode":"67f1de69009f54c0","fromSide":"right","toNode":"9d072e3edacceb00","toSide":"left"},
		{"id":"a1cb7530ed3c1da4","fromNode":"87a040f70a71ac0d","fromSide":"right","toNode":"446749e43ba9f1a7","toSide":"left"},
		{"id":"89b63debb30919f0","fromNode":"049932207a8d8a29","fromSide":"bottom","toNode":"446749e43ba9f1a7","toSide":"top"},
		{"id":"b407aa3bcb359393","fromNode":"fef13f0eaed26c91","fromSide":"right","toNode":"049932207a8d8a29","toSide":"left"},
		{"id":"8382d71b585a459e","fromNode":"82167987beaa431c","fromSide":"right","toNode":"5d4c8f4711e9129c","toSide":"left"},
		{"id":"0d9af3ee5133ddad","fromNode":"5ac3bb28fbed77c9","fromSide":"right","toNode":"9fd3c8c4547c2b2b","toSide":"left"},
		{"id":"3fe31075bd70d6c1","fromNode":"d49e32d1a4038717","fromSide":"right","toNode":"66ec83b728937025","toSide":"left"},
		{"id":"823bd6c0a46e7e45","fromNode":"fef13f0eaed26c91","fromSide":"left","toNode":"87a040f70a71ac0d","toSide":"right"},
		{"id":"b9349615e169b209","fromNode":"761738b6a1649d49","fromSide":"right","toNode":"606314345d2960df","toSide":"left"},
		{"id":"f9ea69d57fdc2313","fromNode":"87d145e78e795476","fromSide":"left","toNode":"606314345d2960df","toSide":"right"},
		{"id":"2b4ba9d0a740dc1d","fromNode":"a546675539180963","fromSide":"left","toNode":"8cc23aafd157dcb5","toSide":"right"},
		{"id":"f46ef72022d7c60c","fromNode":"f70cf1e58c00ce99","fromSide":"right","toNode":"8cc23aafd157dcb5","toSide":"left"},
		{"id":"110c7fc7d1dfc05d","fromNode":"23d53bc9a609131f","fromSide":"right","toNode":"1855ddcb33a37a60","toSide":"left"}
	]
}